<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LegalCopilot - Semantic Clause Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8f9fa; }
        
        .header { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 20px; text-align: center; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .status-bar { 
            background: white; padding: 10px 20px; border-bottom: 1px solid #dee2e6;
            display: flex; justify-content: space-between; align-items: center;
        }
        .status { padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; }
        .status.connected { background: #d4edda; color: #155724; }
        .status.disconnected { background: #f8d7da; color: #721c24; }
        .status.processing { background: #fff3cd; color: #856404; }
        
        .main-layout { display: flex; height: calc(100vh - 140px); }
        
        /* Three-panel layout: 20-50-30 */
        .clause-list { width: 20%; background: white; border-right: 1px solid #dee2e6; overflow-y: auto; }
        .document-viewer { width: 50%; background: white; border-right: 1px solid #dee2e6; overflow-y: auto; }
        .clause-details { width: 30%; background: white; overflow-y: auto; }
        
        /* Upload section */
        .upload-section { 
            text-align: center; padding: 60px 20px; 
            background: white; margin: 20px; border-radius: 12px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .file-input { 
            display: block; margin: 20px auto; padding: 12px; width: 350px;
            border: 2px dashed #dee2e6; border-radius: 8px; background: #f8f9fa;
        }
        .upload-btn { 
            background: linear-gradient(135deg, #28a745, #20c997); 
            color: white; padding: 12px 30px; border: none; border-radius: 8px; 
            cursor: pointer; font-weight: bold; font-size: 16px;
            transition: transform 0.2s ease;
        }
        .upload-btn:hover { transform: translateY(-2px); }
        .upload-btn:disabled { background: #6c757d; cursor: not-allowed; transform: none; }
        
        /* Processing indicator */
        .processing-indicator { 
            display: none; background: #e3f2fd; padding: 20px; border-radius: 8px; margin: 20px;
        }
        .progress-steps { display: flex; justify-content: space-between; margin: 15px 0; }
        .progress-step { 
            padding: 8px 12px; background: #f8f9fa; border-radius: 20px; 
            font-size: 12px; color: #6c757d; border: 2px solid #dee2e6;
        }
        .progress-step.active { background: #007bff; color: white; border-color: #007bff; }
        .progress-step.completed { background: #28a745; color: white; border-color: #28a745; }
        
        /* Clause list styling */
        .clause-list h3 { padding: 15px 20px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; }
        .clause-item {
            margin: 8px 12px; padding: 12px; border-radius: 8px; cursor: pointer;
            border-left: 4px solid #dee2e6; transition: all 0.2s ease;
            background: #f8f9fa;
        }
        .clause-item:hover { background: #e9ecef; transform: translateX(2px); }
        .clause-item.active { background: #e3f2fd; border-left-color: #007bff; }
        .clause-item.high-risk { border-left-color: #dc3545; }
        .clause-item.medium-risk { border-left-color: #ffc107; }
        .clause-item.low-risk { border-left-color: #28a745; }
        
        .clause-type { font-weight: bold; font-size: 14px; }
        .clause-confidence { 
            font-size: 11px; color: #6c757d; 
            background: #fff; padding: 2px 6px; border-radius: 10px; margin-top: 5px; display: inline-block;
        }
        .clause-preview { font-size: 12px; color: #6c757d; margin-top: 5px; }
        
        /* Document viewer - page-by-page structure */
        .document-viewer { position: relative; }
        .document-viewer h3 { 
            padding: 15px 20px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; 
            position: sticky; top: 0; z-index: 10;
        }
        
        .pdf-page { 
            margin: 20px; padding: 25px; 
            background: white; border: 2px solid #dee2e6; border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            min-height: 600px; /* Maintain consistent page height */
        }
        .pdf-page-header { 
            font-weight: bold; color: #007bff; margin-bottom: 20px; 
            padding: 8px 0; border-bottom: 2px solid #e9ecef;
            font-size: 16px;
        }
        .pdf-page-content { 
            line-height: 1.6; font-size: 14px; color: #333;
            white-space: pre-wrap; /* Preserve PDF formatting */
        }
        
        /* Semantic clause highlighting */
        .semantic-highlight {
            background: linear-gradient(120deg, #ffeb3b 0%, #ffc107 100%);
            padding: 3px 6px; border-radius: 4px; cursor: pointer;
            border: 2px solid transparent; transition: all 0.2s ease;
            font-weight: bold; position: relative;
        }
        .semantic-highlight:hover { 
            border-color: #007bff; background: #e3f2fd; 
            transform: scale(1.02);
        }
        .semantic-highlight.high-risk { 
            background: linear-gradient(120deg, #ffcdd2 0%, #f8bbd9 100%); 
            border-color: #dc3545;
        }
        .semantic-highlight.medium-risk { 
            background: linear-gradient(120deg, #fff3cd 0%, #ffeaa7 100%); 
            border-color: #ffc107;
        }
        .semantic-highlight.low-risk { 
            background: linear-gradient(120deg, #d4edda 0%, #c3e6cb 100%); 
            border-color: #28a745;
        }
        
        /* Flash effect for auto-scroll */
        @keyframes flashHighlight {
            0% { background: #007bff; color: white; transform: scale(1.1); }
            50% { background: #0056b3; color: white; transform: scale(1.15); }
            100% { background: inherit; color: inherit; transform: scale(1); }
        }
        .flash-effect { animation: flashHighlight 2s ease-in-out; }
        
        /* Clause details panel */
        .clause-details h3 { 
            padding: 15px 20px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; 
            position: sticky; top: 0;
        }
        .clause-analysis { padding: 20px; }
        .risk-indicator { 
            padding: 8px 16px; border-radius: 20px; font-weight: bold; 
            margin-bottom: 15px; text-align: center;
        }
        .risk-indicator.high { background: #f8d7da; color: #721c24; }
        .risk-indicator.medium { background: #fff3cd; color: #856404; }
        .risk-indicator.low { background: #d4edda; color: #155724; }
        
        .analysis-section { margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .analysis-section h4 { color: #007bff; margin-bottom: 10px; }
        
        .empty-state { 
            text-align: center; padding: 40px 20px; color: #6c757d; 
            font-style: italic;
        }
        
        .hidden { display: none; }
        
        /* Loading animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .pulsing { animation: pulse 1.5s infinite; }
        
        /* Error states */
        .error-message {
            background: #f8d7da; color: #721c24; padding: 15px; 
            border-radius: 8px; margin: 20px; border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèõÔ∏è LegalCopilot</h1>
        <p>Semantic Contract Clause Analysis</p>
    </div>
    
    <div class="status-bar">
        <div>
            <span id="documentStatus">No document loaded</span>
        </div>
        <div>
            <span id="backendStatus" class="status disconnected">Backend: Checking...</span>
        </div>
    </div>

    <div id="uploadSection" class="upload-section">
        <h2>üìÑ Upload Contract for Analysis</h2>
        <p style="color: #6c757d; margin-bottom: 20px;">
            Upload your PDF contract for semantic clause detection and risk analysis
        </p>
        <input type="file" id="fileInput" class="file-input" accept=".pdf" />
        <button id="uploadBtn" class="upload-btn">Analyze Contract</button>
        
        <div id="processingIndicator" class="processing-indicator">
            <div class="pulsing">üîç Processing Contract...</div>
            <div class="progress-steps">
                <div id="step1" class="progress-step">Extract Text</div>
                <div id="step2" class="progress-step">Semantic Analysis</div>
                <div id="step3" class="progress-step">Risk Assessment</div>
                <div id="step4" class="progress-step">Generate View</div>
            </div>
            <div id="processingDetails" style="font-size: 14px; color: #6c757d;">Initializing...</div>
        </div>
    </div>

    <div id="mainLayout" class="main-layout hidden">
        <!-- Left Panel: Clause List (20%) -->
        <div class="clause-list">
            <h3>üéØ Detected Clauses</h3>
            <div id="clauseItems">
                <div class="empty-state">
                    No clauses detected yet
                </div>
            </div>
        </div>

        <!-- Center Panel: Document Viewer (50%) -->
        <div class="document-viewer">
            <h3>üìã Contract Document</h3>
            <div id="documentPages">
                <!-- PDF pages load here with semantic highlighting -->
            </div>
        </div>

        <!-- Right Panel: Clause Details (30%) -->
        <div class="clause-details">
            <h3>üîç Clause Analysis</h3>
            <div id="clauseAnalysis">
                <div class="empty-state">
                    Click a clause to see detailed analysis
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:5001';
        let currentPdf = null;
        let detectedClauses = [];
        let documentText = '';
        
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // Semantic patterns for legal clauses (high-confidence only)
        const SEMANTIC_PATTERNS = {
            governance: {
                patterns: [
                    /holder.*shall.*vote.*shares.*in\s+accordance.*with.*instructions.*provided.*by.*president/gi,
                    /governance.*compromise.*whereby.*holder.*vote.*accordance.*president/gi,
                    /shareholder.*vote.*shares.*accordance.*instructions.*from.*president/gi
                ],
                riskLevel: 'high',
                type: 'Governance Compromise'
            },
            dragAlong: {
                patterns: [
                    /drag.?along.*right.*whereby.*offeror.*holding.*ninety.?five.*per.*cent/gi,
                    /95%.*shares.*offeror.*may.*require.*other.*holders.*sell/gi,
                    /forced.*sale.*provision.*majority.*shareholder.*ninety.?five.*percent/gi
                ],
                riskLevel: 'high',
                type: 'Drag-Along Rights'
            },
            tagAlong: {
                patterns: [
                    /tag.?along.*right.*holder.*sell.*shares.*same.*price.*terms/gi,
                    /co.?sale.*right.*minority.*shareholder.*protection/gi,
                    /holder.*transfer.*shares.*other.*holder.*right.*sell.*same.*terms/gi
                ],
                riskLevel: 'low',
                type: 'Tag-Along Rights'
            },
            priorityAllocation: {
                patterns: [
                    /priority.*allocation.*sale.*price.*distributed.*waterfall/gi,
                    /liquidation.*preference.*distribution.*proceeds.*priority.*order/gi,
                    /waterfall.*distribution.*priority.*shareholders.*allocation/gi
                ],
                riskLevel: 'medium',
                type: 'Priority Allocation'
            },
            nonCompete: {
                patterns: [
                    /non.?compete.*restrictions.*remain.*applicable.*avoidance.*doubts/gi,
                    /competition.*restrictions.*survive.*completion.*transaction/gi,
                    /non.?solicitation.*provisions.*continue.*apply.*after.*sale/gi
                ],
                riskLevel: 'medium',
                type: 'Non-Compete Survival'
            }
        };

        // Check backend connection
        async function checkBackendConnection() {
            const statusElement = document.getElementById('backendStatus');
            try {
                const response = await fetch(`${API_BASE}/health`, { timeout: 5000 });
                if (response.ok) {
                    statusElement.textContent = 'Backend: Connected ‚úÖ';
                    statusElement.className = 'status connected';
                    return true;
                }
            } catch (error) {
                console.warn('Backend connection failed:', error);
            }
            
            statusElement.textContent = 'Backend: Offline';
            statusElement.className = 'status disconnected';
            return false;
        }

        // Update processing step
        function updateProcessingStep(stepNumber, status = 'active') {
            const steps = ['step1', 'step2', 'step3', 'step4'];
            
            // Reset all steps
            steps.forEach((step, index) => {
                const element = document.getElementById(step);
                if (index < stepNumber - 1) {
                    element.className = 'progress-step completed';
                } else if (index === stepNumber - 1) {
                    element.className = `progress-step ${status}`;
                } else {
                    element.className = 'progress-step';
                }
            });
        }

        // Semantic clause detection
        function detectSemanticClauses(text) {
            const detected = [];
            
            Object.entries(SEMANTIC_PATTERNS).forEach(([key, config]) => {
                config.patterns.forEach(pattern => {
                    const matches = [...text.matchAll(pattern)];
                    
                    matches.forEach(match => {
                        const startIndex = match.index;
                        const endIndex = startIndex + match[0].length;
                        
                        // Get surrounding context (200 chars each side)
                        const contextStart = Math.max(0, startIndex - 200);
                        const contextEnd = Math.min(text.length, endIndex + 200);
                        const context = text.substring(contextStart, contextEnd);
                        
                        // Calculate confidence based on pattern specificity
                        const confidence = calculateConfidence(match[0], context);
                        
                        if (confidence > 0.8) { // Only high-confidence matches
                            detected.push({
                                id: `clause_${detected.length}`,
                                type: config.type,
                                text: match[0],
                                context: context,
                                position: startIndex,
                                confidence: confidence,
                                riskLevel: config.riskLevel,
                                fullMatch: match[0]
                            });
                        }
                    });
                });
            });
            
            // Sort by position in document
            return detected.sort((a, b) => a.position - b.position);
        }

        // Calculate confidence score
        function calculateConfidence(matchText, context) {
            let confidence = 0.5; // Base confidence
            
            // Legal language indicators
            const legalTerms = ['shall', 'hereby', 'whereas', 'accordance', 'provisions', 'notwithstanding'];
            const legalCount = legalTerms.reduce((count, term) => 
                count + (context.toLowerCase().includes(term) ? 1 : 0), 0);
            
            confidence += legalCount * 0.05;
            
            // Clause structure indicators
            if (context.includes('Article') || context.includes('Section')) confidence += 0.1;
            if (matchText.length > 50) confidence += 0.1; // Longer matches more reliable
            if (context.includes('%') || context.includes('percent')) confidence += 0.05;
            
            return Math.min(confidence, 0.95); // Cap at 95%
        }

        // Main processing function
        document.getElementById('uploadBtn').addEventListener('click', async function() {
            const fileInput = document.getElementById('fileInput');
            const uploadSection = document.getElementById('uploadSection');
            const mainLayout = document.getElementById('mainLayout');
            const processingIndicator = document.getElementById('processingIndicator');
            const processingDetails = document.getElementById('processingDetails');
            const uploadBtn = document.getElementById('uploadBtn');
            
            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select a PDF file first');
                return;
            }
            
            console.log('üöÄ Starting semantic clause analysis...');
            
            // Show processing
            processingIndicator.style.display = 'block';
            uploadBtn.disabled = true;
            document.getElementById('backendStatus').className = 'status processing';
            document.getElementById('backendStatus').textContent = 'Backend: Processing';
            
            try {
                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                
                // Step 1: Extract Text
                updateProcessingStep(1, 'active');
                processingDetails.textContent = `Extracting text from ${file.name}...`;
                
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                console.log(`üìÑ PDF loaded: ${pdf.numPages} pages`);
                
                let allText = '';
                const pageContents = [];
                
                // Extract text from all pages
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    processingDetails.textContent = `Extracting page ${pageNum} of ${pdf.numPages}...`;
                    
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    
                    pageContents.push({
                        pageNumber: pageNum,
                        text: pageText
                    });
                    
                    allText += pageText + ' ';
                }
                
                documentText = allText;
                updateProcessingStep(1, 'completed');
                
                // Step 2: Semantic Analysis
                updateProcessingStep(2, 'active');
                processingDetails.textContent = 'Performing semantic clause analysis...';
                
                // Check if backend is available for enhanced analysis
                const backendAvailable = await checkBackendConnection();
                
                if (backendAvailable) {
                    try {
                        // Try backend analysis
                        const formData = new FormData();
                        formData.append('file', file);
                        
                        const response = await fetch(`${API_BASE}/analyze-clauses`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                document_text: allText,
                                clause_types: ['governance', 'drag_along', 'tag_along', 'priority_allocation', 'non_compete']
                            })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            detectedClauses = result.detected_clauses || [];
                            console.log('‚úÖ Backend analysis successful:', detectedClauses.length, 'clauses detected');
                        } else {
                            throw new Error(`Backend error: ${response.status}`);
                        }
                    } catch (backendError) {
                        console.warn('Backend analysis failed, using frontend patterns:', backendError);
                        detectedClauses = detectSemanticClauses(allText);
                    }
                } else {
                    // Use frontend semantic patterns
                    detectedClauses = detectSemanticClauses(allText);
                }
                
                updateProcessingStep(2, 'completed');
                console.log('üéØ Semantic analysis complete:', detectedClauses.length, 'clauses detected');
                
                // Step 3: Risk Assessment
                updateProcessingStep(3, 'active');
                processingDetails.textContent = 'Assessing clause risks...';
                
                // Risk assessment already included in detection
                await new Promise(resolve => setTimeout(resolve, 500)); // Brief pause for UX
                updateProcessingStep(3, 'completed');
                
                // Step 4: Generate View
                updateProcessingStep(4, 'active');
                processingDetails.textContent = 'Generating document view...';
                
                // Generate page-by-page view with highlighting
                await generateDocumentView(pageContents);
                
                // Populate clause list
                populateClauseList();
                
                updateProcessingStep(4, 'completed');
                processingDetails.textContent = 'Analysis complete!';
                
                // Update UI
                document.getElementById('documentStatus').textContent = 
                    `${file.name} - ${detectedClauses.length} clauses detected`;
                
                // Show main layout
                setTimeout(() => {
                    uploadSection.classList.add('hidden');
                    mainLayout.classList.remove('hidden');
                    checkBackendConnection(); // Reset backend status
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Processing error:', error);
                document.getElementById('documentPages').innerHTML = 
                    `<div class="error-message">Error processing PDF: ${error.message}</div>`;
                
                // Show main layout even on error
                uploadSection.classList.add('hidden');
                mainLayout.classList.remove('hidden');
            } finally {
                processingIndicator.style.display = 'none';
                uploadBtn.disabled = false;
            }
        });

        // Generate page-by-page document view
        async function generateDocumentView(pageContents) {
            const documentPages = document.getElementById('documentPages');
            let pagesHTML = '';
            
            pageContents.forEach(pageContent => {
                let highlightedText = pageContent.text;
                
                // Apply semantic highlighting
                detectedClauses.forEach((clause, index) => {
                    const regex = new RegExp(
                        clause.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 
                        'gi'
                    );
                    
                    highlightedText = highlightedText.replace(regex, 
                        `<span class="semantic-highlight ${clause.riskLevel}-risk" 
                                data-clause-id="${clause.id}" 
                                data-clause-index="${index}"
                                title="${clause.type} (${Math.round(clause.confidence * 100)}% confidence)">${clause.text}</span>`
                    );
                });
                
                pagesHTML += `
                    <div class="pdf-page" id="page-${pageContent.pageNumber}">
                        <div class="pdf-page-header">üìÑ Page ${pageContent.pageNumber}</div>
                        <div class="pdf-page-content">${highlightedText}</div>
                    </div>
                `;
            });
            
            documentPages.innerHTML = pagesHTML;
        }

        // Populate clause list
        function populateClauseList() {
            const clauseItems = document.getElementById('clauseItems');
            
            if (detectedClauses.length === 0) {
                clauseItems.innerHTML = '<div class="empty-state">No semantic clauses detected</div>';
                return;
            }
            
            const clausesHTML = detectedClauses.map((clause, index) => `
                <div class="clause-item ${clause.riskLevel}-risk" 
                     data-clause-index="${index}" 
                     data-clause-id="${clause.id}">
                    <div class="clause-type">${clause.type}</div>
                    <div class="clause-confidence">Confidence: ${Math.round(clause.confidence * 100)}%</div>
                    <div class="clause-preview">${clause.text.substring(0, 80)}...</div>
                </div>
            `).join('');
            
            clauseItems.innerHTML = clausesHTML;
        }

        // Auto-scroll functionality with visual feedback
        document.addEventListener('click', function(e) {
            const clauseItem = e.target.closest('.clause-item');
            
            if (clauseItem) {
                const clauseIndex = parseInt(clauseItem.dataset.clauseIndex);
                const clause = detectedClauses[clauseIndex];
                
                if (clause) {
                    // Update active state
                    document.querySelectorAll('.clause-item').forEach(item => 
                        item.classList.remove('active'));
                    clauseItem.classList.add('active');
                    
                    // Find highlighted clause in document
                    const targetElement = document.querySelector(`[data-clause-id="${clause.id}"]`);
                    
                    if (targetElement) {
                        // Smooth scroll to target
                        targetElement.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center',
                            inline: 'center'
                        });
                        
                        // Flash effect (2-second duration as per specs)
                        setTimeout(() => {
                            targetElement.classList.add('flash-effect');
                            setTimeout(() => {
                                targetElement.classList.remove('flash-effect');
                            }, 2000);
                        }, 800); // Wait for scroll to complete
                        
                        console.log(`‚úÖ Auto-scrolled to: ${clause.type}`);
                    } else {
                        console.warn(`‚ùå Target element not found for clause: ${clause.id}`);
                    }
                    
                    // Update clause details panel
                    updateClauseDetails(clause);
                }
            }
        });

        // Update clause details panel
        function updateClauseDetails(clause) {
            const clauseAnalysis = document.getElementById('clauseAnalysis');
            
            const riskColor = {
                'high': '#721c24',
                'medium': '#856404',
                'low': '#155724'
            }[clause.riskLevel];
            
            clauseAnalysis.innerHTML = `
                <div class="risk-indicator ${clause.riskLevel}">
                    ${clause.riskLevel.toUpperCase()} RISK CLAUSE
                </div>
                
                <div class="analysis-section">
                    <h4>üè∑Ô∏è Clause Type</h4>
                    <p>${clause.type}</p>
                </div>
                
                <div class="analysis-section">
                    <h4>üìä Confidence Score</h4>
                    <p>${Math.round(clause.confidence * 100)}% - ${
                        clause.confidence > 0.9 ? 'Very High' :
                        clause.confidence > 0.8 ? 'High' : 'Medium'
                    }</p>
                </div>
                
                <div class="analysis-section">
                    <h4>üìù Clause Text</h4>
                    <p style="font-style: italic; background: #f8f9fa; padding: 10px; border-radius: 4px;">
                        "${clause.text}"
                    </p>
                </div>
                
                <div class="analysis-section">
                    <h4>üîç Context</h4>
                    <p style="font-size: 12px; color: #6c757d;">
                        ...${clause.context}...
                    </p>
                </div>
                
                <div class="analysis-section">
                    <h4>‚ö†Ô∏è Risk Analysis</h4>
                    <p>${getRiskAnalysis(clause)}</p>
                </div>
            `;
        }

        // Get risk analysis text
        function getRiskAnalysis(clause) {
            const riskAnalyses = {
                'Governance Compromise': {
                    high: 'This clause significantly limits your voting rights by requiring you to vote according to the president\'s instructions. This could prevent you from protecting your interests in critical decisions.',
                    medium: 'Moderate governance restrictions that may limit your decision-making power.',
                    low: 'Minor governance provisions with limited impact on your voting rights.'
                },
                'Drag-Along Rights': {
                    high: 'If a majority shareholder (95%+) decides to sell, you can be forced to sell your shares at the same terms. You have no choice in the matter once this threshold is reached.',
                    medium: 'Forced sale provisions that activate under certain ownership thresholds.',
                    low: 'Standard drag-along provisions with reasonable protections.'
                },
                'Tag-Along Rights': {
                    high: 'Significant tag-along provisions that could complicate share transfers.',
                    medium: 'Standard tag-along rights that provide some minority protection.',
                    low: 'Favorable provision - gives you the right to sell your shares alongside majority shareholders at the same price and terms, protecting you from being left behind.'
                },
                'Priority Allocation': {
                    high: 'Complex liquidation preferences that may significantly reduce your payout in an exit scenario.',
                    medium: 'The sale proceeds follow a specific waterfall distribution. Depending on your position in the waterfall, you may receive less than expected in a sale scenario.',
                    low: 'Standard liquidation preferences with reasonable terms.'
                },
                'Non-Compete Survival': {
                    high: 'Non-compete restrictions continue after the transaction, significantly limiting your future business activities.',
                    medium: 'Your non-compete and non-solicitation obligations survive the completion of this transaction. This may restrict your business activities even after the deal closes.',
                    low: 'Limited non-compete provisions with reasonable scope and duration.'
                }
            };
            
            return riskAnalyses[clause.type]?.[clause.riskLevel] || 
                   'This clause requires careful review by a legal professional.';
        }

        // Initialize
        console.log('üöÄ LegalCopilot semantic analyzer ready');
        checkBackendConnection();
    </script>
</body>
</html>